/***********************************************************************
 ** Copyright (C) 2010 Movid Authors.  All rights reserved.
 **
 ** This file is part of the Movid Software.
 **
 ** This file may be distributed under the terms of the Q Public License
 ** as defined by Trolltech AS of Norway and appearing in the file
 ** LICENSE included in the packaging of this file.
 **
 ** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 ** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 **
 ** Contact info@movid.org if any conditions of this licensing are
 ** not clear to you.
 **
 **********************************************************************/


#include <math.h>
#include <assert.h>
#include "moDiffuseDistanceModule.h"
#include "../moLog.h"
#include "cv.h"

MODULE_DECLARE(DiffuseDistance, "native", "Diffuse Distance Description");

moDiffuseDistanceModule::moDiffuseDistanceModule() : moImageFilterModule(){

	MODULE_INIT();

	// The size of window around each pixel to calculate diffused value
	this->properties["window_width"] = new moProperty(3);
}

moDiffuseDistanceModule::~moDiffuseDistanceModule() {
}

void moDiffuseDistanceModule::applyFilter(IplImage *src) {
	//copy the source image to calculate depth map
	IplImage *copy = cvCloneImage(src);

	//iterate through the image and look at a window around each pixel
	int step = src->widthStep;
	int height = src->height;
	int width = src->width;
	double min = this->property("min_value").asDouble();
	double max = this->property("max_value").asDouble();
	double cur_val;
	char *data = src->imageData;

	for (int i = 0; i < width; i++) {
		for (int j = 0; j < height; j++) {
			cur_val = ((int) data[j * step + i]);
			if ((min < cur_val) && (cur_val < max)) {
				doubleToPoint p;
				p.first = cur_val;
				p.second.x = i;
				p.second.y = j;
				this->peaks.push_back(p);
			}
		}
	}
}

